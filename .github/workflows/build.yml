name: Build Augment Injector Release

on:
  workflow_dispatch: {}
  schedule:
    - cron: '0 */2 * * *'

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate resources
        run: |
          echo "🔍 Validating required resources..."
          
          # Check required JS files
          for file in interceptor.js token-login-enhanced.js augment-balance-enhanced.js; do
            if [ ! -f "resources/$file" ]; then
              echo "❌ Missing required file: resources/$file"
              exit 1
            fi
            echo "✅ Found: resources/$file"
          done
          
          # Check required config files
          for file in package-json-commands.json balance-package-commands.json README.md; do
            if [ ! -f "resources/$file" ]; then
              echo "❌ Missing required file: resources/$file"
              exit 1
            fi
            echo "✅ Found: resources/$file"
          done
          
          echo "✅ All required resources validated"

      - name: Download Latest VSIX
        run: |
          echo "📥 Downloading latest Augment VSIX..."
          PUBLISHER="augment"
          EXTENSION_NAME="vscode-augment"
          VSIX_URL="https://marketplace.visualstudio.com/_apis/public/gallery/publishers/${PUBLISHER}/vsextensions/${EXTENSION_NAME}/latest/vspackage"
          
          curl -L --compressed -o original.vsix "$VSIX_URL"
          
          # Verify download
          if [ ! -f "original.vsix" ]; then
            echo "❌ Failed to download VSIX"
            exit 1
          fi
          
          echo "✅ VSIX downloaded successfully"
          file original.vsix || true

      - name: Extract VSIX
        run: |
          echo "📦 Extracting VSIX..."
          mkdir -p unpacked_ext
          cd unpacked_ext
          unzip -q ../original.vsix
          cd ..
          echo "✅ VSIX extracted"

      - name: Get version from package.json
        id: get_version
        run: |
          # Find package.json in unpacked extension
          if [ -f "unpacked_ext/package.json" ]; then
            PKG_PATH="unpacked_ext/package.json"
          elif [ -f "unpacked_ext/extension/package.json" ]; then
            PKG_PATH="unpacked_ext/extension/package.json"
          else
            echo "❌ package.json not found"
            exit 1
          fi
          
          VERSION=$(python3 -c "import json; print(json.load(open('$PKG_PATH'))['version'])")
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "Found version: $VERSION"

      - name: Check if version already released
        id: version_check
        run: |
          git fetch --tags --force --quiet
          TAG_NAME="v${{ env.VERSION }}-triple"
          if git tag -l | grep -q "^${TAG_NAME}$"; then
            echo "skip_build=true" >> $GITHUB_OUTPUT
            echo "Tag ${TAG_NAME} already exists, skipping build"
          else
            echo "skip_build=false" >> $GITHUB_OUTPUT
            echo "Tag ${TAG_NAME} does not exist, proceeding with build"
          fi

      - name: Skip build notification
        if: steps.version_check.outputs.skip_build == 'true'
        run: |
          echo "✅ Version ${{ env.VERSION }} already released (triple). Skipping packaging and release."

      - name: Perform Triple Injection
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "🚀 Performing triple injection..."
          
          python3 << 'EOF'
          import os, sys, shutil, json, re
          from pathlib import Path
          from datetime import datetime

          def log(msg):
              print(f"[INFO] {msg}")

          def error(msg):
              print(f"[ERROR] {msg}")
              sys.exit(1)

          # Find extension.js file
          def find_extension_js(base_dir):
              candidates = [
                  base_dir / 'extension' / 'out' / 'extension.js',
                  base_dir / 'extension' / 'dist' / 'extension.js', 
                  base_dir / 'out' / 'extension.js',
                  base_dir / 'dist' / 'extension.js',
                  base_dir / 'extension.js'
              ]
              
              for candidate in candidates:
                  if candidate.exists():
                      return candidate, candidate.parent
              return None, None

          # Simple injection at head
          def inject_head(js_file, inject_content, tag):
              log(f"Injecting {tag} at head...")
              content = js_file.read_text(encoding='utf-8')
              
              # Remove existing injection if present
              pattern = rf"// === {re.escape(tag)} Start ===.*?// === {re.escape(tag)} End ===\s*"
              content = re.sub(pattern, '', content, flags=re.DOTALL)
              
              # Create injection
              timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
              injection = f"// === {tag} Start ===\\n"
              injection += f"// 注入时间: {timestamp}\\n"
              injection += inject_content + "\\n"
              injection += f"// === {tag} End ===\\n\\n"
              
              js_file.write_text(injection + content, encoding='utf-8')
              return True

          # Simple injection at tail
          def inject_tail(js_file, inject_content, tag):
              log(f"Injecting {tag} at tail...")
              content = js_file.read_text(encoding='utf-8')
              
              # Remove existing injection if present
              pattern = rf"// === {re.escape(tag)} Start ===.*?// === {re.escape(tag)} End ===\s*"
              content = re.sub(pattern, '', content, flags=re.DOTALL)
              
              # Create injection
              timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
              injection = f"\\n\\n// === {tag} Start ===\\n"
              injection += f"// 注入时间: {timestamp}\\n"
              injection += inject_content + "\\n"
              injection += f"// === {tag} End ==="
              
              js_file.write_text(content + injection, encoding='utf-8')
              return True

          try:
              # Find extension.js
              unpacked = Path('unpacked_ext')
              js_path, js_dir = find_extension_js(unpacked)

              if not js_path:
                  error("extension.js not found!")

              log(f"Found extension.js: {js_path}")

              # Fix file permissions (files from ZIP might be read-only)
              import stat
              js_path.chmod(stat.S_IWRITE | stat.S_IREAD)
              log("File permissions fixed")

              # Read injection files
              resources = Path('resources')
              interceptor_content = (resources / 'interceptor.js').read_text(encoding='utf-8')
              token_content = (resources / 'token-login-enhanced.js').read_text(encoding='utf-8')
              balance_content = (resources / 'augment-balance-enhanced.js').read_text(encoding='utf-8')

              # Copy module files to extension directory
              shutil.copy(resources / 'token-login-enhanced.js', js_dir / 'token-login-enhanced.js')
              shutil.copy(resources / 'augment-balance-enhanced.js', js_dir / 'augment-balance-enhanced.js')
              log("Module files copied")

              # Perform triple injection
              inject_head(js_path, interceptor_content, 'Augment Interceptor Injection')
              inject_tail(js_path, token_content, 'Augment Token Login Enhanced Injection')
              inject_tail(js_path, balance_content, 'Augment Balance Enhanced Injection')

              log("✅ Triple injection completed successfully")
              
          except Exception as e:
              error(f"Injection failed: {e}")
          EOF

      - name: Update package.json and README
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "📝 Updating package.json and README..."
          
          python3 << 'EOF'
          import json
          from pathlib import Path

          def log(msg):
              print(f"[INFO] {msg}")

          try:
              unpacked = Path('unpacked_ext')
              resources = Path('resources')
              
              # Find package.json
              pkg_candidates = [unpacked / 'package.json', unpacked / 'extension' / 'package.json']
              pkg_path = None
              for p in pkg_candidates:
                  if p.exists():
                      pkg_path = p
                      break
              
              if pkg_path:
                  log(f"Updating package.json: {pkg_path}")

                  # Fix file permissions
                  import stat
                  pkg_path.chmod(stat.S_IWRITE | stat.S_IREAD)

                  with open(pkg_path, 'r', encoding='utf-8') as f:
                      pkg_data = json.load(f)

                  # Update display name
                  pkg_data['displayName'] = 'Augment 注入增强版'
                  
                  # Add commands and configuration
                  contributes = pkg_data.setdefault('contributes', {})
                  commands = contributes.setdefault('commands', [])
                  existing_commands = {cmd.get('command') for cmd in commands}
                  
                  # Load and add token commands
                  with open(resources / 'package-json-commands.json', 'r', encoding='utf-8') as f:
                      token_commands = json.load(f)['commands_to_add']
                  for cmd in token_commands:
                      if cmd['command'] not in existing_commands:
                          commands.append(cmd)
                  
                  # Load and add balance commands + configuration
                  with open(resources / 'balance-package-commands.json', 'r', encoding='utf-8') as f:
                      balance_config = json.load(f)
                      balance_commands = balance_config['commands_to_add']
                      balance_configuration = balance_config['configuration_to_add']
                  
                  for cmd in balance_commands:
                      if cmd['command'] not in existing_commands:
                          commands.append(cmd)
                  
                  contributes['configuration'] = balance_configuration
                  
                  # Ensure activationEvents includes onUri
                  activation_events = pkg_data.setdefault('activationEvents', [])
                  if 'onUri' not in activation_events:
                      activation_events.append('onUri')
                  
                  # Save updated package.json
                  with open(pkg_path, 'w', encoding='utf-8') as f:
                      json.dump(pkg_data, f, indent=2, ensure_ascii=False)
                  
                  log("package.json updated")
              
              # Update README
              readme_header_file = resources / 'README.md'
              if readme_header_file.exists():
                  header = readme_header_file.read_text(encoding='utf-8').rstrip() + '\n\n'
                  readme_candidates = [unpacked / 'README.md', unpacked / 'extension' / 'README.md']
                  readme_path = None
                  for rp in readme_candidates:
                      if rp.exists():
                          readme_path = rp
                          break
                  
                  if readme_path:
                      # Fix file permissions
                      import stat
                      readme_path.chmod(stat.S_IWRITE | stat.S_IREAD)
                      body = readme_path.read_text(encoding='utf-8')
                      readme_path.write_text(header + body, encoding='utf-8')
                      log("README header prepended")
                  else:
                      (unpacked / 'README.md').write_text(header, encoding='utf-8')
                      log("README created with header")
              
              log("✅ Package metadata updated successfully")
              
          except Exception as e:
              print(f"[ERROR] Failed to update metadata: {e}")
              exit(1)
          EOF

      - name: Repackage VSIX
        if: steps.version_check.outputs.skip_build == 'false'
        run: |
          echo "📦 Repackaging VSIX..."
          PATCHED_VSIX_NAME="augment-vscode-v${{ env.VERSION }}-triple.vsix"
          echo "PATCHED_VSIX_NAME=${PATCHED_VSIX_NAME}" >> $GITHUB_ENV

          cd unpacked_ext
          # VSIX is just a ZIP file
          zip -r "../${PATCHED_VSIX_NAME}" . -x "*.git*"
          cd ..

          echo "✅ VSIX repackaged: ${PATCHED_VSIX_NAME}"
          ls -l *.vsix || true

      - name: Create Release
        if: steps.version_check.outputs.skip_build == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: "v${{ env.VERSION }}-triple"
          name: "Augment v${{ env.VERSION }} (Triple Injection)"
          body: |
            🚀 **Augment 三重注入增强版**

            **注入功能：**
            - ✅ 拦截器注入 
            - ✅ Token登录增强 
            - ✅ 余额增强功能 

            **版本信息：**
            - 原版本: v${{ env.VERSION }}
            - 注入模式: Triple
            - 构建时间: ${{ github.run_id }}

          files: ${{ env.PATCHED_VSIX_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
